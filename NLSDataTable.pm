use BinaryFile;

###############################################################################
#
# class NLSDataTable
#
# Generate NLS+ data tables from other sub-tables.
# Sub-tables (tables within a table) are generated by the DataTable class.
# These sub-tables can be 8:4:4 table, 12:4:4 table, flat tables, or other
# table types supported by DataTable class.
#
# A table can be divided into different "sections."
# For example, for the casing table, there is a section that contains the 
# 8:4:4 table for uppercasing table, and this section has a name "Uppercase."
# 
# The name of the section can be informational so that it can be printed when
# the PrintTable() is called for debugging purpose.
# Besides, the name of the section can also be referenced when an offset to that section
# is needed.  The offset is always reference to the beginning of the table.
# 
# 
###############################################################################

package NLSDataTable;

# public
sub New
###############################################################################
#
#   Actions:
#       Create an instance of NLSDataTable.
#
#   Returns:
#        An instance of NLSDataTable
#
#   Parameters:
#       $endian         Specify the endianess of the table.
#       $tableName      Specify the name of the output table
#
###############################################################################
{
    my ($endian, $fileName) = @_;

    my $self = {};

    #
    # Define instance variables for this class.
    #

    # This indicates if we should emit a big-Endian or little-Endian table.
    # 0 => little-Endian
    # 1 => Big-Endian
    $BinaryFile::g_bigEndian = $self->{m_endian} = $endian;            
    # The output file name
    $self->{m_fileName} = $fileName;

    print "Creating $fileName.\n";

    my $outputFileName = '>' . $fileName;
    open OUTPUTFILE, $outputFileName || die "Can't create $fileName";
    binmode OUTPUTFILE;

    $self->{m_hFile} = *OUTPUTFILE{IO};

    # The byte string to be generated.  This maintains the real content of the table.
    $self->{m_bytes} = "";
    # The current offset in the table.  This is constantly updated when different sections
    # of tables are added.
    $self->{m_offset} = 0;

    # Hash table to store the data for a offset entry in the table.
    $self->{m_offsetSectionPositions} = {};

    # Hash table to map a named section to its offset.
    $self->{m_sectionOffset} = {};

    # Hash table to map a forward reference
    $self->{m_forwardRef} = {};
    
    bless ($self);
    return ($self);
}

# private
sub GetCurrentOffset
###############################################################################
#
# A simple helper function so that it looks better when refers to the current
# offset.
#   Parameters:
#       None.
#
#   Returns:
#       The current offset in the table to be generated.
#   
###############################################################################
{
    my ($self) = @_;
    return ($self->{m_offset});
}


# public
sub AddSection
###############################################################################
# 
# Add the section into the table.
# A section has a name to be associated with it.  Besides, the current offset 
# will be associated with this section.
# 
# Parameters:
#   $sectionName    The name of the section to be added.
#
# Returns:
#   None.
#
###############################################################################
{
    my ($self, $sectionName) = @_;

    my $value;
    if (defined($value = $self->{m_offsetSectionPositions}->{$sectionName})) 
    {
        #
        # If there is offset refered to this section, update the offset right now.
        # Previously, the section was filled with zero.
        #
        
        # Get the the data of the offset.
        my $offset;
        my $size;
        my $type;
        ($offset, $size, $type) = split(/\,/, $value);

        if ($type eq "DWORD")
        {
            # The offset is in DWORD.
            # Update the defined offset value in m_bytes with the current offset.
            substr($self->{m_bytes}, $offset, $size) = BinaryFile::GetDWordBytes(GetCurrentOffset($self));
        } else
        {
            die "AddSection: Unsupported type.";
        }
    }
    # This section has no offset defined for it.  Just add it to the 
    $self->{m_sectionOffset}->{$sectionName} = GetCurrentOffset($self);
}

# public
sub AddFixedUnicodeString
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $sectionName, $str, $length) = @_;

    AddSection($self, $sectionName);
    if (length($str) >= $length - 1)
    {
        die "NLSDataTable::AddFixedUnicodeString(): the length of [$str] exceeds $length.";
    }
    AddBytes($self, BinaryFile::GetFixedUnicodeStringBytes($str, $length));
}

# public
sub AddVersion
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $sectionName, $v1, $v2, $v3, $v4) = @_;

    AddSection($self, $sectionName);
    AddBytes($self, BinaryFile::GetWordBytes($v1));
    AddBytes($self, BinaryFile::GetWordBytes($v2));
    AddBytes($self, BinaryFile::GetWordBytes($v3));
    AddBytes($self, BinaryFile::GetWordBytes($v4));
}

sub AddBytes
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $str) = @_;

    $self->{m_bytes} = $self->{m_bytes} . $str;
    $self->{m_offset} += length($str)
}

# public
sub EmitTable
###############################################################################
#
#
#
###############################################################################
{
    my ($self ) = @_;

    syswrite $self->{m_hFile}, $self->{m_bytes};
    close $self->{m_hFile};
}

# public
sub PrintTable
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $hFile) = @_;
    my $i;
    my $j;

    my $element;
    my %offsetToSection = reverse(%{$self->{m_sectionOffset}});
    
    for ($i = 0; $i < length($self->{m_bytes}); $i++)
    {
        if (defined($offsetToSection{$i}))
        {
            printf $hFile "\n---- %04x: %-20s ----\n", $i, $offsetToSection{$i};
            if ($i % 16 == 0)
            {
                printf $hFile "%08x: ", $i;
            } else 
            {
                printf $hFile "          ";
            }
            for ($j = 0; $j < ($i % 16); $j++) 
            {
                printf $hFile "   ";
            }           
        } else 
        {
            if ($i % 16 == 0)
            {            
                if ($i != 0)
                {
                    print $hFile "    ";
                    for ($j = (($i-1) >> 4) * 16; $j < $i; $j++)
                    {
                        my $ascii = ord(substr($self->{m_bytes}, $j, 1));
                        if ($ascii >= 32 && $ascii <= 127)
                        {
                            print $hFile substr($self->{m_bytes}, $j, 1);
                        } else
                        {
                            print $hFile ".";
                        }
                    }
                }
                printf $hFile "\n%08x: ", $i;
            }
        }
        printf $hFile "%02X ", ord(substr($self->{m_bytes}, $i, 1));
    }
    printf $hFile "\n\n";
}

# public
sub AddDWordOffsetOfTable
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $sectionName, $offsetSectionName) = @_;
    AddSection($self, $sectionName);
    
    $self->{m_offsetSectionPositions}->{$offsetSectionName} = GetCurrentOffset($self) . "," . "4,DWORD";
    print $self->{m_offsetSectionPositions}->{$sectionName};
    # Write 0 to this position for now.  This will be updated when the table is emitted.
    AddBytes($self, BinaryFile::GetDWordBytes(0));
}

# public
sub AddTable
###############################################################################
#
#
#
###############################################################################
{
    my ($self, $sectionName, $pDataTable) = @_;

    AddSection($self, $sectionName);

    AddBytes($self, $pDataTable->GetBytes(GetCurrentOffset($self)));
}

# public
sub AddAligntmentBytes
###############################################################################
#
# Add bytes to make sure that the table is aligned at the specified offset.
#
###############################################################################
{
    my ($self, $offset) = @_;

    if ($offset != 2 && $offset != 4 && $offset != 8 && $offset != 16) {
        die "NLSDataTable::AddAligntmentBytes(): $offset should be at 2, 4, 8, or 16";
    }
    $mod = $self->{m_offset} % $offset;
    if ($mod != 0) {
        my $i;
        for ($i = 0; $i < ($offset - $mod); $i++)
        {
            AddBytes($self, BinaryFile::GetByte(0));
        }
    }
}

# public
sub AddForwardRefBytes
###############################################################################
#
# Add bytes which will be updated when table is emitted.
# This should be used with UpdateBytesForwardRef
#
###############################################################################
{
    my ($self, $forwardRefName, $values) = @_;

    my $currOffset = $self->{m_offset};
    $self->{m_bytes} = $self->{m_bytes} . $values;
    # Put the length into the hash table so that we an verify
    $self->{m_forwardRef}->{$forwardRefName} = $currOffset . "," . length($values);
    $self->{m_offset} += length($values);
}

# public
sub UpdateForwardRefBytes
###############################################################################
#
# Update bytes which will be updated when table is emitted.
#
###############################################################################
{
    my ($self, $forwardRefName, $values) = @_;

    my $store = $self->{m_forwardRef}->{$forwardRefName};
 
    if (!defined($self->{m_forwardRef}->{$forwardRefName})) {
        die "NLSDataTable::UpdateBytesForwardRef: Forward reference [$forwardRefName] is not created by AddBytesForwardRef()";
    }
    
    my ($offset, $len) = split(/\,/, $store);
    if (length($values) != $len) {
        die "NLSDataTable::UpdateBytesForwardRef: Forward reference [$forwardRefName] does not have the right length\n" .
            "   Expected Length: $len\n" .
            "   Result Length  : " . length($values);
    }

    substr($self->{m_bytes}, $offset, $len) = $values;
}
1;
